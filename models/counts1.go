// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Counts1 Counts1
// swagger:model Counts1
type Counts1 struct {

	// apiaccountingconfig
	// Required: true
	Apiaccountingconfig *int32 `json:"apiaccountingconfig"`

	// bigdatainstance
	// Required: true
	Bigdatainstance *int32 `json:"bigdatainstance"`

	// bigdatasnapshot
	// Required: true
	Bigdatasnapshot *int32 `json:"bigdatasnapshot"`

	// dbinstance
	// Required: true
	Dbinstance *int32 `json:"dbinstance"`

	// dbsnapshot
	// Required: true
	Dbsnapshot *int32 `json:"dbsnapshot"`

	// divvyorganizationservice
	// Required: true
	Divvyorganizationservice *int32 `json:"divvyorganizationservice"`

	// dnszone
	// Required: true
	Dnszone *int32 `json:"dnszone"`

	// hypervisor
	// Required: true
	Hypervisor *int32 `json:"hypervisor"`

	// instance
	// Required: true
	Instance *int32 `json:"instance"`

	// instancereservation
	// Required: true
	Instancereservation *int32 `json:"instancereservation"`

	// internetgateway
	// Required: true
	Internetgateway *int32 `json:"internetgateway"`

	// loadbalancer
	// Required: true
	Loadbalancer *int32 `json:"loadbalancer"`

	// mcinstance
	// Required: true
	Mcinstance *int32 `json:"mcinstance"`

	// mcsnapshot
	// Required: true
	Mcsnapshot *int32 `json:"mcsnapshot"`

	// networkflowlog
	// Required: true
	Networkflowlog *int32 `json:"networkflowlog"`

	// networkinterface
	// Required: true
	Networkinterface *int32 `json:"networkinterface"`

	// networkpeer
	// Required: true
	Networkpeer *int32 `json:"networkpeer"`

	// privateimage
	// Required: true
	Privateimage *int32 `json:"privateimage"`

	// privatenetwork
	// Required: true
	Privatenetwork *int32 `json:"privatenetwork"`

	// privatesubnet
	// Required: true
	Privatesubnet *int32 `json:"privatesubnet"`

	// publicip
	// Required: true
	Publicip *int32 `json:"publicip"`

	// resourceaccesslist
	// Required: true
	Resourceaccesslist *int32 `json:"resourceaccesslist"`

	// resourceaccesslistrule
	// Required: true
	Resourceaccesslistrule *int32 `json:"resourceaccesslistrule"`

	// routetable
	// Required: true
	Routetable *int32 `json:"routetable"`

	// serviceaccesskey
	// Required: true
	Serviceaccesskey *int32 `json:"serviceaccesskey"`

	// servicealarm
	// Required: true
	Servicealarm *int32 `json:"servicealarm"`

	// servicecertificate
	// Required: true
	Servicecertificate *int32 `json:"servicecertificate"`

	// serviceencryptionkey
	// Required: true
	Serviceencryptionkey *int32 `json:"serviceencryptionkey"`

	// servicegroup
	// Required: true
	Servicegroup *int32 `json:"servicegroup"`

	// servicepolicy
	// Required: true
	Servicepolicy *int32 `json:"servicepolicy"`

	// serviceregion
	// Required: true
	Serviceregion *int32 `json:"serviceregion"`

	// servicerole
	// Required: true
	Servicerole *int32 `json:"servicerole"`

	// serviceuser
	// Required: true
	Serviceuser *int32 `json:"serviceuser"`

	// snapshot
	// Required: true
	Snapshot *int32 `json:"snapshot"`

	// sshkeypair
	// Required: true
	Sshkeypair *int32 `json:"sshkeypair"`

	// storagecontainer
	// Required: true
	Storagecontainer *int32 `json:"storagecontainer"`

	// volume
	// Required: true
	Volume *int32 `json:"volume"`
}

// Validate validates this counts1
func (m *Counts1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateApiaccountingconfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBigdatainstance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBigdatasnapshot(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDbinstance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDbsnapshot(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDivvyorganizationservice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDnszone(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHypervisor(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstancereservation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInternetgateway(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLoadbalancer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMcinstance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMcsnapshot(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkflowlog(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkinterface(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkpeer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrivateimage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrivatenetwork(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrivatesubnet(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePublicip(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResourceaccesslist(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResourceaccesslistrule(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRoutetable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServiceaccesskey(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServicealarm(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServicecertificate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServiceencryptionkey(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServicegroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServicepolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServiceregion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServicerole(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServiceuser(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshot(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSshkeypair(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStoragecontainer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolume(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Counts1) validateApiaccountingconfig(formats strfmt.Registry) error {

	if err := validate.Required("apiaccountingconfig", "body", m.Apiaccountingconfig); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateBigdatainstance(formats strfmt.Registry) error {

	if err := validate.Required("bigdatainstance", "body", m.Bigdatainstance); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateBigdatasnapshot(formats strfmt.Registry) error {

	if err := validate.Required("bigdatasnapshot", "body", m.Bigdatasnapshot); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateDbinstance(formats strfmt.Registry) error {

	if err := validate.Required("dbinstance", "body", m.Dbinstance); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateDbsnapshot(formats strfmt.Registry) error {

	if err := validate.Required("dbsnapshot", "body", m.Dbsnapshot); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateDivvyorganizationservice(formats strfmt.Registry) error {

	if err := validate.Required("divvyorganizationservice", "body", m.Divvyorganizationservice); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateDnszone(formats strfmt.Registry) error {

	if err := validate.Required("dnszone", "body", m.Dnszone); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateHypervisor(formats strfmt.Registry) error {

	if err := validate.Required("hypervisor", "body", m.Hypervisor); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateInstance(formats strfmt.Registry) error {

	if err := validate.Required("instance", "body", m.Instance); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateInstancereservation(formats strfmt.Registry) error {

	if err := validate.Required("instancereservation", "body", m.Instancereservation); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateInternetgateway(formats strfmt.Registry) error {

	if err := validate.Required("internetgateway", "body", m.Internetgateway); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateLoadbalancer(formats strfmt.Registry) error {

	if err := validate.Required("loadbalancer", "body", m.Loadbalancer); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateMcinstance(formats strfmt.Registry) error {

	if err := validate.Required("mcinstance", "body", m.Mcinstance); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateMcsnapshot(formats strfmt.Registry) error {

	if err := validate.Required("mcsnapshot", "body", m.Mcsnapshot); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateNetworkflowlog(formats strfmt.Registry) error {

	if err := validate.Required("networkflowlog", "body", m.Networkflowlog); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateNetworkinterface(formats strfmt.Registry) error {

	if err := validate.Required("networkinterface", "body", m.Networkinterface); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateNetworkpeer(formats strfmt.Registry) error {

	if err := validate.Required("networkpeer", "body", m.Networkpeer); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validatePrivateimage(formats strfmt.Registry) error {

	if err := validate.Required("privateimage", "body", m.Privateimage); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validatePrivatenetwork(formats strfmt.Registry) error {

	if err := validate.Required("privatenetwork", "body", m.Privatenetwork); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validatePrivatesubnet(formats strfmt.Registry) error {

	if err := validate.Required("privatesubnet", "body", m.Privatesubnet); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validatePublicip(formats strfmt.Registry) error {

	if err := validate.Required("publicip", "body", m.Publicip); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateResourceaccesslist(formats strfmt.Registry) error {

	if err := validate.Required("resourceaccesslist", "body", m.Resourceaccesslist); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateResourceaccesslistrule(formats strfmt.Registry) error {

	if err := validate.Required("resourceaccesslistrule", "body", m.Resourceaccesslistrule); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateRoutetable(formats strfmt.Registry) error {

	if err := validate.Required("routetable", "body", m.Routetable); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateServiceaccesskey(formats strfmt.Registry) error {

	if err := validate.Required("serviceaccesskey", "body", m.Serviceaccesskey); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateServicealarm(formats strfmt.Registry) error {

	if err := validate.Required("servicealarm", "body", m.Servicealarm); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateServicecertificate(formats strfmt.Registry) error {

	if err := validate.Required("servicecertificate", "body", m.Servicecertificate); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateServiceencryptionkey(formats strfmt.Registry) error {

	if err := validate.Required("serviceencryptionkey", "body", m.Serviceencryptionkey); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateServicegroup(formats strfmt.Registry) error {

	if err := validate.Required("servicegroup", "body", m.Servicegroup); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateServicepolicy(formats strfmt.Registry) error {

	if err := validate.Required("servicepolicy", "body", m.Servicepolicy); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateServiceregion(formats strfmt.Registry) error {

	if err := validate.Required("serviceregion", "body", m.Serviceregion); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateServicerole(formats strfmt.Registry) error {

	if err := validate.Required("servicerole", "body", m.Servicerole); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateServiceuser(formats strfmt.Registry) error {

	if err := validate.Required("serviceuser", "body", m.Serviceuser); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateSnapshot(formats strfmt.Registry) error {

	if err := validate.Required("snapshot", "body", m.Snapshot); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateSshkeypair(formats strfmt.Registry) error {

	if err := validate.Required("sshkeypair", "body", m.Sshkeypair); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateStoragecontainer(formats strfmt.Registry) error {

	if err := validate.Required("storagecontainer", "body", m.Storagecontainer); err != nil {
		return err
	}

	return nil
}

func (m *Counts1) validateVolume(formats strfmt.Registry) error {

	if err := validate.Required("volume", "body", m.Volume); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Counts1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Counts1) UnmarshalBinary(b []byte) error {
	var res Counts1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
